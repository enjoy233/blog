<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Sorting Algorithm in JavaScript - Quicksort and Heap Sort | TaoAlpha's Blog</title><meta name="description" content="quicksort and heap sort"><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:title" content="Sorting Algorithm in JavaScript - Quicksort and Heap Sort | TaoAlpha's Blog"><meta property="og:description" content="quicksort and heap sort"><meta property="og:url" content="undefined"><meta property="og:image" content="http://taoalpha.github.io/images/newblog.jpg"><meta property="og:type" content="website"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="TaoAlpha's Blog" type="application/atom+xml">
<link rel="alternate" href="/blog/rss2.xml" title="TaoAlpha's Blog" type="application/rss+xml">
</head><body class="post"><aside class="home-menu"><nav class="home-icon-con upside"><a href="/blog/" class="home-menu-icon brand">涛</a><a href="/blog/timeline" class="home-menu-icon"><i class="fas fa-map-marker-alt"></i></a><a aria-label="Click to take you to the search box." class="home-menu-icon search-trigger hint--right"><i class="fas fa-search"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact hidden"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.github.io" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div></nav><nav class="home-icon-con downside"><a href="/blog/rss2.xml" class="home-menu-icon rss"><i class="fas fa-rss"></i></a><a href="/blog/about/" class="home-menu-icon"><i class="fas fa-smile"></i></a><span id="dark-mode" class="home-menu-icon hidden"><i class="fas fa-adjust"></i></span></nav></aside><div class="stars"></div><div class="twinkling"></div><div id="progress-bar" class="hidden"><span class="bg"></span></div><article id="content"><div class="main"><section class="entry"><h1 class="entry-title">Sorting Algorithm in JavaScript - Quicksort and Heap Sort</h1><div class="meta-top"><a href="https://taoalpha.github.io"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2016-01-19</span><span class="wordage">6567 words</span><span class="readspeed">19 minutes to read</span></div><div class="entry-content"><p>Last time we have finished the four different sorting algorithms including : insertion sort and selection sort, bubble sort and merge sort, check on Series section for these posts.</p>
<p>Now let’s continue playing with another one or two.</p>
<h2 id="Median-Sort-and-Quicksort"><a href="#Median-Sort-and-Quicksort" class="headerlink" title="Median Sort and Quicksort"></a>Median Sort and Quicksort</h2><h3 id="Median-Sort"><a href="#Median-Sort" class="headerlink" title="Median Sort"></a>Median Sort</h3><p>Similiar with merge sort, we still use divide and conquer, the basic approach for many problems, but what if we use some statistical information about the array that need to be sorted? Like the median of the array.</p>
<p>If we know the median, we can sort the array into 2 distinct subarrays of about half the size: left with all elements smaller than the median, and right with all elements bigger or equal to median. And we keep doing this for all subarrays, finally we will get a sorted array.</p>
<p>That gives us the MEDIAN SORT.</p>
<h3 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h3><p>Median sort is a nice start, but it still has one problem: how to find the the median of an array? Before we atually put our efforts on solving this problem, we should consider about another problem: how about we use some other attributes instead of median? Our purpose is divide the array into two parts, we don’t need them to be the same size. By thinking this way, we may consider choose any value in the array and use this value as a separator and divide the array into subarrays.</p>
<p>This is quicksort, and the value we choose as a separator is called pivot.</p>
<p>Now let’s show the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function">(<span class="params">list,left,right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> idx;</span><br><span class="line">  <span class="keyword">if</span>(list.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// left and right  must be number, default value :  0 and list.length - 1</span></span><br><span class="line">  left = (left^<span class="number">0</span>) !== left ? <span class="number">0</span> : left</span><br><span class="line">  right = (right^<span class="number">0</span>) !== right ? list.length<span class="number">-1</span> : right</span><br><span class="line"></span><br><span class="line">  <span class="comment">// divide the array from left to right into two subarrays</span></span><br><span class="line">  <span class="comment">// return the index of the separator</span></span><br><span class="line">  idx = partition(list,left,right) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(left &lt; idx - <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// keep doing quicksort on left subarray until it can not be separated again</span></span><br><span class="line">    quickSort(list,left,idx - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(idx &lt; right)&#123;</span><br><span class="line">    <span class="comment">// keep doing quicksort on right subarray until it can not be separated again</span></span><br><span class="line">    quickSort(list,idx,right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function">(<span class="params">list,begin,end</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> pivot = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(tail-head+<span class="number">1</span>)+head), <span class="comment">// random pivot index </span></span><br><span class="line">      pivot_value = list[pivot]; <span class="comment">// pivot value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// divide into two subarrays using the pivot value with two pointers</span></span><br><span class="line">  <span class="keyword">while</span>(begin &lt;= end)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// skip all 'good' ones in right</span></span><br><span class="line">    <span class="keyword">while</span>(list[end]&gt;pivot_value)&#123;</span><br><span class="line">      end --</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip all 'good' ones in left </span></span><br><span class="line">    <span class="keyword">while</span>(list[begin]&lt;pivot_value)&#123;</span><br><span class="line">      begin ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap the 'bad' pairs to make them 'good'</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt;= end)&#123;</span><br><span class="line">      swap(list,begin,end)</span><br><span class="line">      begin ++</span><br><span class="line">      end --</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the separator line</span></span><br><span class="line">  <span class="keyword">return</span> begin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap function</span></span><br><span class="line"><span class="keyword">var</span> swap = <span class="function">(<span class="params">list,first,second</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = list[first]</span><br><span class="line">  list[first] = list[second]</span><br><span class="line">  list[second] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With all comments, the code should be easy to understand.</p>
<p>Quicksort is famous and popular for its speed especially after linux start using it as the default sorting algorithm. Normally, if we know nothing about the distribution of our array and speed is the most important reason you consider about, then use quicksort.</p>
<p>In above example, we choose the pivot randomly. Normally, its good enough for using. But actually there are a lot of strategies and researches on how to choose a good pivot. Like always choose the first or last or middle, or use median, median-of-k…etc But normally, using randomly pivot will give you an average O(nlogn). If you want to learn more about these strategies, just google it :)</p>
<h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h3><p>Before we go to the concept and code, we should know what is a heap:</p>
<blockquote><p>a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.</p>
<p>In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.</p>
<footer><strong>WikiPedia</strong><cite><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener">Heap (data structure) - wikipedia</a></cite></footer></blockquote>

<p>Got any inspirations ? Think this way: Max heap =&gt; the head of the heap is the max of the array. This is true for any max heap, so we remove the max and rebuild a heap with rest elements, we get the second largest… Yeah, you got it ?! :)</p>
<p>Now what we need to do is using array represent the heap which is pretty much a array tree:</p>
<p>for any element with index - idx:</p>
<ul>
<li>left child : idx*2 + 1</li>
<li>right child: idx*2 + 2</li>
<li>Show me the code !!!</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort - here we use max heap</span></span><br><span class="line"><span class="keyword">var</span> heapSort = <span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">  buildHeap(list);  <span class="comment">// now we have the max value</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = list.length<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// always put max value to the end of the current heap</span></span><br><span class="line">    <span class="comment">// so the end of the array will always be sorted and gradually expanded to the entire array</span></span><br><span class="line">    swap(list,<span class="number">0</span>,i); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// since we change the head of the heap</span></span><br><span class="line">    <span class="comment">// so we need redo the heap to get the new max of the heap</span></span><br><span class="line">    heapify(list,<span class="number">0</span>,i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line">buildHeap(list)&#123;</span><br><span class="line">  <span class="comment">// start from the second last level of the tree which is the parent of the last element</span></span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = mid;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// make sure every node of the tree is heapify</span></span><br><span class="line">    heapify(list,i,list.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">heapify(list,idx,len)&#123;</span><br><span class="line">  <span class="comment">// len means the number of elements current heap has</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> left = <span class="number">2</span>*idx + <span class="number">1</span>,</span><br><span class="line">      right = <span class="number">2</span>*idx + <span class="number">2</span>,</span><br><span class="line">      largest;  <span class="comment">// temp value to store the index of largest element of this tree unit</span></span><br><span class="line"></span><br><span class="line">  largest = left &lt; len &amp;&amp; list[left] &gt; list[idx] ? left: idx;</span><br><span class="line">  largest = right &lt; len &amp;&amp; list[right] &gt; list[len] ? right : largest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we have a new largest, swap it and redo heapify to make sure entire heap is correct</span></span><br><span class="line">  <span class="keyword">if</span>(largest !== idx)&#123;</span><br><span class="line">    swap(list,largest,idx)</span><br><span class="line">    heapify(list,largest,len)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// swap function - same as before</span></span><br></pre></td></tr></table></figure>

<p>Heap Sort is really fast, sometimes it is even faster than quicksort since it will guarantee the O(nlogn) even in the worst case. But normally in average case, the quicksort is a little faster.</p>
<h2 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h2><p>I believe I still have 2 posts for this serie, one will talk about the radix, and the other will be the counting and bucket sort. See ya.</p>
</div><div class="post-info"><span class="category"><i class="fas fa-briefcase"></i><a href="/blog/categories/tech">tech</a></span><span class="tags"><i class="fas fa-tags"></i><a href="/blog/tags/sort">sort</a><a href="/blog/tags/algorithm">algorithm</a></span></div></section><div class="widgets"><aside id="menuIndex" class="sidenav hidden"></aside><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: The way I learn Algorithm<i class="fas fa-arrow-down expand"></i><i class="collapse fas fa-arrow-up"></i></h2><ul class="article-list hidden"><li><a href="/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/" data-id='0'>JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</a></li><li><a href="/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" data-id='1' class="current">Sorting Algorithm in JavaScript - Quicksort and Heap Sort</a></li></ul></aside><aside class="sidenav"><div class="recent-posts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="/blog/2020/07/06/thoughts-recommendation-to-new-grads-on-job-choices/">给新计算机毕业生在工作选择上的一些建议</a></li><li><a href="/blog/2020/07/04/travel-working-holiday-visa-3/">打工度假 (三)</a></li><li><a href="/blog/2020/07/02/travel-working-holiday-visa-2/">打工度假 (二)</a></li><li><a href="/blog/2020/07/02/tech-what-i-have-done-to-restart-this-blog/">我都做了哪些来复活本博客的</a></li><li><a href="/blog/2020/07/01/travel-working-holiday-visa/">打工度假 (一)</a></li></ul></div></aside></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><div class="comments"><script>const gitment = new Gitment({
  id: new Date('Tue Jan 19 2016 07:00:00 GMT-0500').toISOString(),
  owner: 'taoalpha',
  repo: 'blog',
  oauth: {
    client_id: '875872ffb3955d0ffe20',
    client_secret: '46040668c536860a9e2e9a8508c513309e3840b5',
  },
});
gitment.render(document.querySelector('.comments'));
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>