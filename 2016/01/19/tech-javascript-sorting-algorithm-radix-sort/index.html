<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript Sorting Algorithm - Radix Sort and Bucket Sort | TaoAlpha's Blog</title><meta name="description" content="Two basic sorting algorithms, radix and bucket."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:title" content="JavaScript Sorting Algorithm - Radix Sort and Bucket Sort | TaoAlpha's Blog"><meta property="og:description" content="Two basic sorting algorithms, radix and bucket."><meta property="og:url" content="undefined"><meta property="og:image" content="http://taoalpha.github.io/images/newblog.jpg"><meta property="og:type" content="website"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="TaoAlpha's Blog" type="application/atom+xml">
<link rel="alternate" href="/blog/rss2.xml" title="TaoAlpha's Blog" type="application/rss+xml">
</head><body class="post"><aside class="home-menu"><nav class="home-icon-con upside"><a href="/blog/" class="home-menu-icon brand">涛</a><a href="/blog/timeline" class="home-menu-icon"><i class="fas fa-map-marker-alt"></i></a><a aria-label="Click to take you to the search box." class="home-menu-icon search-trigger hint--right"><i class="fas fa-search"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact hidden"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.github.io" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div></nav><nav class="home-icon-con downside"><a href="/blog/rss2.xml" class="home-menu-icon rss"><i class="fas fa-rss"></i></a><a href="/blog/about/" class="home-menu-icon"><i class="fas fa-smile"></i></a><span id="dark-mode" class="home-menu-icon hidden"><i class="fas fa-adjust"></i></span></nav></aside><div class="stars"></div><div class="twinkling"></div><div id="progress-bar" class="hidden"><span class="bg"></span></div><article id="content"><div class="main"><section class="entry"><h1 class="entry-title">JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</h1><div class="meta-top"><a href="https://taoalpha.github.io"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2016-01-19</span><span class="wordage">7151 words</span><span class="readspeed">21 minutes to read</span></div><div class="entry-content"><h2 id="Comparison-based-sorting-algorithms"><a href="#Comparison-based-sorting-algorithms" class="headerlink" title="Comparison based sorting algorithms"></a>Comparison based sorting algorithms</h2><p>We have discussed all popular comparison based sorting algorithms: <a href="http://taoalpha.github.io/blog/2015/10/29/tech-javascript-sorting-algorithm-1/">insertion sort and selection sort</a>, <a href="http://taoalpha.github.io/blog/2015/10/29/tech-javascript-sorting-algorithm-2/">bubble sort and merge sort</a>, <a href="http://taoalpha.github.io/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/">Quicksort and Heap Sort</a>.</p>
<p>All these algorithms are great under most of conditions, but their lower bound is O(nlogn), they can not do better.</p>
<p>If for some reason, we want to achieve better than nLogn, we have to find some other ways.</p>
<p>About why the lower bound of all comparison based sorting algorithms is nlogn ?</p>
<h2 id="Why-nlogn"><a href="#Why-nlogn" class="headerlink" title="Why nlogn"></a>Why nlogn</h2><p>For any array with n elements, it has n! possible orders. Since we are using comparison based, suppose we are building a decision tree for all these possible orders, and h is the height of the decision tree and also is how many number of comparisons we need to get down to the leaves. Then we should have:</p>
<p>2^h &gt;= n! which means: the total number of leaves should be enough to cover all possible orders of our array.</p>
<p>Then we would get h &gt;= nlogn for approximation.</p>
<h2 id="Non-Comparison-based-sorting-algorithms"><a href="#Non-Comparison-based-sorting-algorithms" class="headerlink" title="Non-Comparison based sorting algorithms"></a>Non-Comparison based sorting algorithms</h2><p>So if we want to get over the nlogn, we have to ask help from some non-comparison based ways.</p>
<p>If you knew or heard about the sorting algorithms, you should know we have several famous non-comparison based sorting algorithms: counting sort, bucket sort and radix sort.</p>
<p>And lets talk about them today, one by one :)</p>
<h3 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h3><p>Imagine this situation:</p>
<p>You have a deck of playing cards in random order(without jokers), and you want to sort them into the ascending order from A to K. What you gonna do ? Possibly you will count the cards and group them into 13 groups from A to K, and then combine these groups from A to K.</p>
<p>This is a classical counting sort. Once we are sure how many groups we have in our array or we know that the elements in our array are coming from a distribution from a to b. Then we can group them into (b - a + 1) buckets and loop over the array, put elements into proper buckets and then combine them.</p>
<p>Here is the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counting sort</span></span><br><span class="line">countingSort(list)&#123;</span><br><span class="line">  <span class="keyword">var</span> bucket = [],idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assign each element to its bucket</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">    bucket[list[i]] = bucket[list[i]] || <span class="number">0</span></span><br><span class="line">    bucket[list[i]] ++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now combine all the buckets</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; bucket.length;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(bucket[i] &amp;&amp; bucket[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// skip empty buckets and loop over every elements in a bucket</span></span><br><span class="line">      list[idx++] = i;</span><br><span class="line">      bucket[i] --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>The counting sort is amazing fast : O(n+k), k is the number of buckets we have. But it costs too much space, and if we don’t know the distribution of elements, it maybe have a lot of empty buckets which is a waste of space.</p>
<p>Bucket sort is an optimization of counting sort, instead of only assigning same elements into one bucket, it will put several elements into one bucket but make sure the it is ascending from the point of buckets which means: for i,j buckets, if i &lt; j, we know any elements in i will smaller than any elements in j.</p>
<p>By doing this, we can divide the entire array into a lot of small subarrays, and now we can just use any comparison based sorting algorithm to sort the small arrays.</p>
<p>Same as counting sort, if we have a wonderful distribution of our elements, it would be O(n + klogb), k is the number of buckets and b is the number of elements in one bucket, to sort the entire array. But the worst case, all elements assigned into the same buckets, it will degrade to the comparison based sorting algorithm we use, but only when you choose a really bad method to group.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucketSort</span></span><br><span class="line">bucketSort(list,bucketCount)&#123;</span><br><span class="line">  <span class="comment">// only for numbers</span></span><br><span class="line">  <span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>,list),  <span class="comment">// get the min</span></span><br><span class="line">      buckets = [],</span><br><span class="line">      bucket_count = bucketCount || <span class="number">200</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// build the bucket and distribute the elements in the list</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">    <span class="comment">// this is a simple hash function that will make sure the basic rule of bucket sort</span></span><br><span class="line">    <span class="keyword">var</span> newIndex = <span class="built_in">Math</span>.floor( (list[i] - min) / bucket_count );  </span><br><span class="line"></span><br><span class="line">    buckets[newIndex] = buckets[newIndex] || []</span><br><span class="line">    buckets[newIndex].push(list[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// refill the elements into the list</span></span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;buckets.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> buckets[i] !== <span class="string">"undefined"</span>)&#123;</span><br><span class="line">      <span class="comment">// select those non-empty buckets</span></span><br><span class="line">      insertionSort(buckets[i]);  <span class="comment">// use any sorting algorithm would be fine</span></span><br><span class="line">      <span class="comment">// sort the elements in the bucket</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;buckets[i].length;j++)&#123;</span><br><span class="line">        list[idx++] = buckets[i][j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h3><p>Counting sort and Bucket sort are great, but they are too space-consuming and sometimes they are even slower than comparison based ones. Like if we have a really sparse array coming from 0 to n^2, then counting sort would down to O(n^2), and also if we don’t know the distribution of all elements in the array, we might choose an unefficient way to do the hash part for bucket sort, we could still get O(n^2).</p>
<p>Radix is here to help us out of this trouble. The idea of Radix Sort is to do digit by digit sort starting from least significant digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.</p>
<p>For example: we have: [101, 203, 5, 87, 76, 48], using radix sort:</p>
<p>[101,203,5,76,87,48] &lt;- last digits<br>[101,203,5,48,76,87] &lt;- second last digits<br>[5,48,76,87,101,203] &lt;- the first digits<br>Using zero when the number doesn’t have this digit.</p>
<p>Now lets show the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper function to get the last nth digit of a number</span></span><br><span class="line"><span class="keyword">var</span> getDigit = <span class="function"><span class="keyword">function</span>(<span class="params">num,nth</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// get last nth digit of a number</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(nth--)&#123;</span><br><span class="line">    ret = num % <span class="number">10</span></span><br><span class="line">    num = <span class="built_in">Math</span>.floor((num - ret) / <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// radixSort</span></span><br><span class="line">radixSort(list)&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log10(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,list))),  </span><br><span class="line">      <span class="comment">// get the length of digits of the max value in this array</span></span><br><span class="line">      digitBuckets = [],</span><br><span class="line">      idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;max+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the digit buckets according to this digit</span></span><br><span class="line">    digitBuckets = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;list.length;j++)&#123;</span><br><span class="line">      <span class="keyword">var</span> digit = getDigit(list[j],i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      digitBuckets[digit] = digitBuckets[digit] || [];</span><br><span class="line">      digitBuckets[digit].push(list[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the list according to this digit</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> t = <span class="number">0</span>; t&lt; digitBuckets.length;t++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(digitBuckets[t] &amp;&amp; digitBuckets[t].length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;digitBuckets[t].length;j++)&#123;</span><br><span class="line">          list[idx++] = digitBuckets[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The time complexity for radix sort is : O(d*(n+b)), d is the number of digits the array has, b is the buckets we have, normal it is 10 for base 10 system.</p>
<p>Cool ha :)</p>
<h2 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h2><p>Since I combine radix sort with bucket sort and counting sort, so this is the last post about sorting algorithms. But for this serie, I think I will have another post talking about when we should use which algorithm.</p>
<p>See ya.</p>
<p>Oh, and also, I combine all these codes together and create a gist for it: Soting Algorithms in JS.</p>
</div><div class="post-info"><span class="category"><i class="fas fa-briefcase"></i><a href="/blog/categories/tech">tech</a></span><span class="tags"><i class="fas fa-tags"></i><a href="/blog/tags/sort">sort</a><a href="/blog/tags/algorithm">algorithm</a></span></div></section><div class="widgets"><aside id="menuIndex" class="sidenav hidden"></aside><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: The way I learn Algorithm<i class="fas fa-arrow-down expand"></i><i class="collapse fas fa-arrow-up"></i></h2><ul class="article-list hidden"><li><a href="/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/" data-id='0' class="current">JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</a></li><li><a href="/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" data-id='1'>Sorting Algorithm in JavaScript - Quicksort and Heap Sort</a></li></ul></aside><aside class="sidenav"><div class="recent-posts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="/blog/2020/07/06/thoughts-recommendation-to-new-grads-on-job-choices/">给新计算机毕业生在工作选择上的一些建议</a></li><li><a href="/blog/2020/07/04/travel-working-holiday-visa-3/">打工度假 (三)</a></li><li><a href="/blog/2020/07/02/travel-working-holiday-visa-2/">打工度假 (二)</a></li><li><a href="/blog/2020/07/02/tech-what-i-have-done-to-restart-this-blog/">我都做了哪些来复活本博客的</a></li><li><a href="/blog/2020/07/01/travel-working-holiday-visa/">打工度假 (一)</a></li></ul></div></aside></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><div class="comments"><script>const gitment = new Gitment({
  id: new Date('Tue Jan 19 2016 07:00:00 GMT-0500').toISOString(),
  owner: 'taoalpha',
  repo: 'blog',
  oauth: {
    client_id: '875872ffb3955d0ffe20',
    client_secret: '46040668c536860a9e2e9a8508c513309e3840b5',
  },
});
gitment.render(document.querySelector('.comments'));
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>