<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript the Definitive Guide (2) | TaoAlpha's Blog</title><meta name="description" content="学习JS中的一等公民 - function. 也是本书第八章内容的一些心得和笔记分享."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:title" content="JavaScript the Definitive Guide (2) | TaoAlpha's Blog"><meta property="og:description" content="学习JS中的一等公民 - function. 也是本书第八章内容的一些心得和笔记分享."><meta property="og:url" content="undefined"><meta property="og:image" content="http://taoalpha.github.io/images/newblog.jpg"><meta property="og:type" content="website"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="TaoAlpha's Blog" type="application/atom+xml">
<link rel="alternate" href="/blog/rss2.xml" title="TaoAlpha's Blog" type="application/rss+xml">
</head><body class="post"><aside class="home-menu"><nav class="home-icon-con upside"><a href="/blog/" class="home-menu-icon brand">涛</a><a href="/blog/timeline" class="home-menu-icon"><i class="fas fa-map-marker-alt"></i></a><a aria-label="Click to take you to the search box." class="home-menu-icon search-trigger hint--right"><i class="fas fa-search"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact hidden"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.github.io" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div></nav><nav class="home-icon-con downside"><a href="/blog/rss2.xml" class="home-menu-icon rss"><i class="fas fa-rss"></i></a><a href="/blog/about/" class="home-menu-icon"><i class="fas fa-smile"></i></a><span id="dark-mode" class="home-menu-icon hidden"><i class="fas fa-adjust"></i></span></nav></aside><div class="stars"></div><div class="twinkling"></div><div id="progress-bar" class="hidden"><span class="bg"></span></div><article id="content"><div class="main"><section class="entry"><h1 class="entry-title">JavaScript the Definitive Guide (2)</h1><div class="meta-top"><a href="https://taoalpha.github.io"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2015-06-18</span><span class="wordage">7876 words</span><span class="readspeed">23 minutes to read</span></div><div class="entry-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为JS中的一等公民, <code>function</code>(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录<code>JavaScript: the definitive Guide</code>一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的<code>closure</code>. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>对每一个function而言, 都自动会有一个内置的<code>arguments</code>对象, 用它就可以访问传入的参数了. 通常来说<code>arguments</code>对象我们只会用在不定长传参的函数上, 但<code>arguments</code>本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是<code>callee</code>函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments.callee 即调用当前执行的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*<span class="built_in">arguments</span>.callee(x<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如上, 就实现了一个很简单的&gt;2阶乘计算了</span></span><br></pre></td></tr></table></figure>

<p>需要特别注意的就是<code>callee</code>作为<code>arguments</code>对象的一个方法, 是可以跟随<code>arguments</code>作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.</p>
<p>既然说到<code>arguments</code>, 就多说两句喽. 首先<code>arguments</code>算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过<code>.length</code>直接调用获取长度的, 需要使用<code>Object.keys(object_name).length</code>才能获得). 但是它本身和<code>array.length</code>有很大的差别, 其中最大的一个差别就是: 无法通过<code>.length</code>直接更改数组长度.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.length = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// output: [1,3,4,undefined x 2]</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">arguments</span>.length = <span class="number">5</span>;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)&#125;)(<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// output: [10,1,2]</span></span><br></pre></td></tr></table></figure>

<p>可以看到通过对<code>arguments.length</code>直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.</p>
<p>PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向<code>array.length</code>赋值也算是一个修改<code>array</code>长度的方法喽~</p>
<p>PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.</p>
<h3 id="Function的property"><a href="#Function的property" class="headerlink" title="Function的property"></a>Function的property</h3><p>请先看下述代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f.temp = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.length);</span><br><span class="line">  <span class="built_in">console</span>.log(f.temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2 1 "test"</span></span><br></pre></td></tr></table></figure>

<p>首先, 我们看一下我们前两个输出值:</p>
<p>  如上所述,<code>arguments.length</code>即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的<code>arguments.callee.length</code>又是什么呢? 为什么它输出的是1呢? </p>
<p>  根据之前的介绍, 我们当知道<code>arguments.callee</code>是代指当前的函数<code>f()</code>, 那么对应的<code>arguments.callee.length</code>即我们的函数<code>f</code>的length了. 对于<code>Function</code>这个对象而言, 它所拥有的<code>length</code>这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;</p>
<p>其次, 我们自定义了一个<code>f</code>的属性<code>temp</code>, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? </p>
<p>  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把<code>f.temp</code>写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数<code>f</code>, 接着才开始运行我们的<code>f.temp</code>赋值语句. 自然就不会报错说<code>f</code>没有定义了~</p>
<p>PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如<code>var a = 2;</code>也是拆解为<code>var a; a = 2</code>两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出<code>not defined</code>的错误;</p>
<h3 id="reserved-word-identifier-keyword"><a href="#reserved-word-identifier-keyword" class="headerlink" title="reserved word, identifier, keyword"></a>reserved word, identifier, keyword</h3><p>这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:</p>
<ul>
<li><strong>identifier:</strong> 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为<code>identifier</code>, 取其标识之意, 用以作为其名称以便代用;</li>
<li><strong>reserved word:</strong> 与<code>identifier</code>相对, <code>reserved word</code>则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作<code>identifier</code>;</li>
<li><strong>keyword:</strong> 作为语言语法的组成部分之一, <code>keyword</code>通常都会有着特定的含义, 绝大多数的<code>keyword</code>都是<code>reserved word</code>, 但也有少量语法中存在<code>keyword</code>不是<code>reserved word</code>的情况, 比如<code>fortran</code>就没有<code>reserved word</code>的概念, 它的所有<code>keyword</code>都可以用作<code>identifier</code>;</li>
</ul>
<p><code>reserved word</code>和<code>keyword</code>确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在<code>reserved word</code>不是<code>keyword</code>的情况, 比如<a href="https://en.wikipedia.org/wiki/Reserved_word" title="reserved word - wiki" target="_blank" rel="noopener">java中的<code>goto</code>就是一个<code>reserved word</code>, 但本身又不是一个<code>keyword</code>, 所以可以说<code>goto</code>这个词基本在java中是完全废弃的</a>~ 那他们为啥要定义这个<code>goto</code>呢?? <a href="http://stackoverflow.com/questions/2545103/is-there-a-goto-statement-in-java" title="why keep the goto in java" target="_blank" rel="noopener">有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者<strong>James Gosling</strong>最初加了<code>goto</code>的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把<code>goto</code>从<code>reserved word</code>此表中删去.</a></p>
<p>PS. 很多时候也有人完全不区分<code>reserved word</code>和<code>keyword</code>的区别, 完全等同二者为”不能用来做<code>identifier</code>的词”.</p>
<h3 id="closure-闭包"><a href="#closure-闭包" class="headerlink" title="closure - 闭包"></a>closure - 闭包</h3><p>在javascript中, 一个<code>function</code>由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即<code>closure</code>. 不过单独一个独立函数的<code>closure</code>并没有什么值得说的意义, 因为其执行的环境, 即我们称之为<code>scope</code>的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下<code>closure</code>都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个<code>reference</code>指向函数的话, 事情就变得好玩多了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(id++)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()();f()();f()()</span><br><span class="line"><span class="comment">// output: 1,1,1</span></span><br><span class="line"><span class="comment">// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;</span></span><br><span class="line"><span class="comment">// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k = f();</span><br><span class="line">k();k();k()</span><br><span class="line"><span class="comment">// output: 1,2,3</span></span><br><span class="line"><span class="comment">// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; </span></span><br><span class="line"><span class="comment">// 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留</span></span><br><span class="line"><span class="comment">// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(id++)&#125;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">f();f();f()</span><br><span class="line"><span class="comment">// output: 1,2,3</span></span><br><span class="line"><span class="comment">// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.</span></span><br></pre></td></tr></table></figure>

<p>可以说上述基本就是<code>closure</code>最基本的内容了, 而<code>closure</code>作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: <a href="http://jmvidal.cse.sc.edu/talks/javascript/breakpointsusingclosures.html" title="Breakpoints using javascript closures" target="_blank" rel="noopener">你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.</a></p>
<p>因为原作<code>trimpath</code>上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function implements a breakpoint. It repeatedly prompts the user</span></span><br><span class="line"><span class="comment">// for an expression, evaluates it with the supplied self-inspecting closure,</span></span><br><span class="line"><span class="comment">// and displays the result.  It is the closure that provides access to the</span></span><br><span class="line"><span class="comment">// scope to be inspected, so each function must supply its own closure.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Inspired by Steve Yen's breakpoint() function at</span></span><br><span class="line"><span class="comment">// http://trimpath.com/project/wiki/TrimBreakpoint</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inspect</span>(<span class="params">inspector, title</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> expression, result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can use a breakpoint to turn off subsequent breakpoints by</span></span><br><span class="line">    <span class="comment">// creating a property named "ignore" on this function.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"ignore"</span> <span class="keyword">in</span> <span class="built_in">arguments</span>.callee) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Figure out how to prompt the user</span></span><br><span class="line">        <span class="keyword">var</span> message = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// If we were given a title, display that first</span></span><br><span class="line">        <span class="keyword">if</span> (title) message = title + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// If we've already evaluated an expression, display it and its value</span></span><br><span class="line">        <span class="keyword">if</span> (expression) message += <span class="string">"\n"</span> + expression + <span class="string">" ==&gt; "</span> + result + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> expression = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// We always display at least a basic prompt:</span></span><br><span class="line">        message += <span class="string">"Enter an expression to evaluate, or just click cancel to see the next step of current calculation."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the user's input, displaying our prompt and using the</span></span><br><span class="line">        <span class="comment">// last expression as the default value this time.</span></span><br><span class="line">        expression = prompt(message, expression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the user didn't enter anything (or clicked Cancel),</span></span><br><span class="line">        <span class="comment">// they're done and so we return, ending the breakpoint.</span></span><br><span class="line">        <span class="keyword">if</span> (!expression) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Otherwise, use the supplied closure to evaluate the expression</span></span><br><span class="line">        <span class="comment">// in the scope that is being inspected. </span></span><br><span class="line">        <span class="comment">// The result will be displayed on the next iteration.</span></span><br><span class="line">        result = inspector(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inspector = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">eval</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        inspect (inspector, <span class="string">"Entering factorial()"</span>);</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                result = result * n;</span><br><span class="line">                n--;</span><br><span class="line">                inspect(inspector, <span class="string">"factorial() loop with current result:"</span>+result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inspect(inspector, <span class="string">"Exiting factorial()"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">inspect(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> <span class="built_in">eval</span>(x);&#125;, <span class="string">'Hello'</span>)</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>closure</code>让你可以写出更加复杂的js代码, 但是本身<code>closure</code>的使用还是要慎重的, 因为<code>closure</code>需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~</p>
<h3 id="Function-constructor"><a href="#Function-constructor" class="headerlink" title="Function constructor"></a>Function constructor</h3><p>类似Array, String等都有着一个对应的类, 可以允许你通过<code>new</code>来创建对象. Function也有自己对应的<code>Function()</code>类, 可以通过:<code>new Function()</code>来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的<code>function</code>关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:</p>
<ul>
<li>new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: <code>var cc = new ClassFunction(params)</code> ==&gt; <code>var cc = new Object();ClassFunction.call(cc,params)</code></li>
<li><code>new Function()</code>不接收函数名参数, 即其创建的都是<code>anonymous function</code>;</li>
<li><code>new Function()</code>不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;</li>
</ul>
<h2 id="谜题"><a href="#谜题" class="headerlink" title="谜题"></a>谜题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name : <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Object&#123;name:"My Object"&#125;; "The Window"</span></span><br></pre></td></tr></table></figure>

<p>上述定义中, 为什么嵌套函数没有继承上层函数的<code>this</code>呢? 反而继承了全局的<code>this</code>?</p>
<p><strong>猜测解答:</strong> <code>this</code>这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, <code>this</code>指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" title="Issue 1" target="_blank" rel="noopener">阮一峰博客</a>. </p>
</div><div class="post-info"><span class="category"><i class="fas fa-briefcase"></i><a href="/blog/categories/readings">readings</a></span><span class="tags"><i class="fas fa-tags"></i><a href="/blog/tags/js">js</a><a href="/blog/tags/reading-notes">reading notes</a></span></div></section><div class="widgets"><aside id="menuIndex" class="sidenav hidden"></aside><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: Basic Guide for JavaScript<i class="fas fa-arrow-down expand"></i><i class="collapse fas fa-arrow-up"></i></h2><ul class="article-list hidden"><li><a href="/blog/2015/06/17/readings-reading-javascript-the-definitive-guide-1/" data-id='0'>JavaScript the Definitive Guide (1)</a></li><li><a href="/blog/2015/06/18/readings-javascript-the-definitive-guide-2/" data-id='1' class="current">JavaScript the Definitive Guide (2)</a></li><li><a href="/blog/2015/06/22/readings-javascript-the-definitive-guide-3/" data-id='2'>JavaScript the Definitive Guide (3)</a></li><li><a href="/blog/2015/06/23/readings-javascript-the-definitive-guide-4/" data-id='3'>JavaScript the Definitive Guide (4)</a></li><li><a href="/blog/2015/06/24/readings-javascript-the-definitive-guide-5/" data-id='4'>JavaScript the Definitive Guide (5)</a></li><li><a href="/blog/2015/06/25/readings-javascript-the-definitive-guide-6/" data-id='5'>JavaScript the Definitive Guide (6)</a></li></ul></aside><aside class="sidenav"><div class="recent-posts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="/blog/2020/07/04/travel-working-holiday-visa-3/">打工度假 (三)</a></li><li><a href="/blog/2020/07/02/travel-working-holiday-visa-2/">打工度假 (二)</a></li><li><a href="/blog/2020/07/02/tech-what-i-have-done-to-restart-this-blog/">我都做了哪些来复活本博客的</a></li><li><a href="/blog/2020/07/01/travel-working-holiday-visa/">打工度假 (一)</a></li><li><a href="/blog/2020/06/30/tech-gitment-and-gittalk/">Gitment and Gitalk</a></li></ul></div></aside></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><div class="comments"><script>const gitment = new Gitment({
  id: new Date('Thu Jun 18 2015 06:00:00 GMT-0400').toISOString(),
  owner: 'taoalpha',
  repo: 'blog',
  oauth: {
    client_id: '875872ffb3955d0ffe20',
    client_secret: '46040668c536860a9e2e9a8508c513309e3840b5',
  },
});
gitment.render(document.querySelector('.comments'));
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>