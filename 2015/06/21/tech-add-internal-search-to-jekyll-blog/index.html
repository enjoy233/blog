<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 自建倒排, 为 Jekyll 博客添加搜索功能 | TaoAlpha's Blog</title><meta name="description" content="静态博客的一大缺陷就是无法实现一些复杂的功能, 比如搜索. 本文通过jieba分词以及自定义插件而实现在jekyll编译过程中内建倒排索引, 再利用js做简单的分词处理与倒排索引配合从而实现最粗糙的搜索功能."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:title" content="自建倒排, 为 Jekyll 博客添加搜索功能 | TaoAlpha's Blog"><meta property="og:description" content="静态博客的一大缺陷就是无法实现一些复杂的功能, 比如搜索. 本文通过jieba分词以及自定义插件而实现在jekyll编译过程中内建倒排索引, 再利用js做简单的分词处理与倒排索引配合从而实现最粗糙的搜索功能."><meta property="og:url" content="undefined"><meta property="og:image" content="http://taoalpha.github.io/images/newblog.jpg"><meta property="og:type" content="website"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="TaoAlpha's Blog" type="application/atom+xml">
<link rel="alternate" href="/blog/rss2.xml" title="TaoAlpha's Blog" type="application/rss+xml">
</head><body class="post"><aside class="home-menu"><nav class="home-icon-con upside"><a href="/blog/" class="home-menu-icon brand">涛</a><a href="/blog/timeline" class="home-menu-icon"><i class="fas fa-map-marker-alt"></i></a><a aria-label="Click to take you to the search box." class="home-menu-icon search-trigger hint--right"><i class="fas fa-search"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact hidden"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.github.io" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div></nav><nav class="home-icon-con downside"><a href="/blog/rss2.xml" class="home-menu-icon rss"><i class="fas fa-rss"></i></a><a href="/blog/about/" class="home-menu-icon"><i class="fas fa-smile"></i></a><span id="dark-mode" class="home-menu-icon hidden"><i class="fas fa-adjust"></i></span></nav></aside><div class="stars"></div><div class="twinkling"></div><div id="progress-bar" class="hidden"><span class="bg"></span></div><article id="content"><div class="main"><section class="entry"><h1 class="entry-title">自建倒排, 为 Jekyll 博客添加搜索功能</h1><div class="meta-top"><a href="https://taoalpha.github.io"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2015-06-21</span><span class="wordage">10821 words</span><span class="readspeed">31 minutes to read</span></div><div class="entry-content"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>作为博客, 搜索功能一般来说都算是标配之一了. 而Jekyll作为静态博客, 则很难实现这种动态的实时的搜索请求. 所以通常来说, Jekyll 博客想要添加搜索功能的话, 无外乎以下几种方法:</p>
<ul>
<li>Google/Baidu自定义搜索或者更简单的”site”限定域搜索, 简单易行, 一个链接搞定, 主要适用于内容较多,搜索引擎友好收录较多的站点;</li>
<li>接入第三方服务, 目前博主知道的做这种博客全文搜索服务的有两家: <a href="http://www.searchify.com/documentation/api#searching" target="_blank" rel="noopener">IndexTank</a> 以及 <a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>. 这两种的接入方式也略有不同, 后面我会分别介绍以下;</li>
<li>自建: 这种比较费力不讨好, 目前也没什么人用的感觉… 当然, 博主这次就简单尝试了下…</li>
</ul>
<h2 id="自建"><a href="#自建" class="headerlink" title="自建"></a>自建</h2><p>想要给jekyll自建一个内部搜索的话, 需要先清楚以下几点:</p>
<ul>
<li>jekyll是静态博客, 静态就导致其所有页面都是编译好的, 没有复杂的数据库更没有和数据库交互的功能, 同时其一旦编译, 那么所有支持的功能都只能由JavaScript实现了;</li>
<li>搜索通常发生的几个环节为: <ul>
<li>准备工作: 分词-&gt;索引-&gt;倒排索引</li>
<li>查询过程: Query查询-&gt;Query分词-&gt;比对倒排-&gt;获取匹配结果-&gt;展示</li>
</ul>
</li>
<li>因为静态的原因, 所以我计划的搜索的工作流为: 本地编译的过程中建立一份倒排索引, 前端查询则使用js, 根据query匹配倒排, 用js解析处理展示结果;</li>
</ul>
<p>下面具体介绍下各个环节:</p>
<h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>分词可以说是搜索的根本, 没有好的分词, 一切都免谈. 目前流行的分词, 尤其是中文分词也有不少, 但考虑到我们需要结合jekyll使用, 所以尽量找有现成ruby的. 所幸在<a href="http://rubygems.org/" target="_blank" rel="noopener">RubyGems</a>里面找到了”jieba_rb”模块, 正好”结巴分词”也可以说是目前开源中做的很不错的一个中文分词了~ <a href="https://github.com/altkatz/jieba_rb" target="_blank" rel="noopener">Jieba_Rb Github</a>是其项目所在地址, 有兴趣的可以围观之. 而且最好的是它不仅支持分词, 还支持关键字提取, 而这个对jekyll的自建搜索而言是至关重要的.</p>
<p>** 因为如果全文分词做倒排的话, 倒排文档会很庞大, 这样对于js前端处理倒排的时候压力就会很大, 所以如果每个博文都只用其关键字来做倒排, 那么就能在保证一定的质量的同时, 确保不会产生太大的性能问题. **</p>
<p>安装<code>jieba_rb</code>是非常容易的, 你可以根据自己的情况利用<code>bundle</code>或者<code>gem</code>直接安装~</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>选好的分词库, 我们就可以正式开始制作倒排了, 有了 <a href="/blog/2015/06/01/tech-jekyll-tag-page/">建立Tag专属页</a>的经验, 我们可以采用类似的方法来创建一个建立search页的插件:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="comment"># file: _plugins/search.rb</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"jieba_rb"</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"json"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入'jieba_rb'和'json'两个库. 后者主要是为了将Hash值转为string的时候用的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Jekyll</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SearchPage</span> &lt; Page</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(site, base, dir,h,l)</span></span></span><br><span class="line">      <span class="comment"># 初始化page的设定, 因为考虑到写入json文件的二次请求, 不如直接写入到页面内, 这样可以保证搜索的速度, 同时文本本身请求压力比较小, 也就不用增加多次请求了.</span></span><br><span class="line">      @site = site</span><br><span class="line">      @base = base</span><br><span class="line">      @dir = dir</span><br><span class="line">      @name = <span class="string">'index.html'</span></span><br><span class="line">      <span class="keyword">self</span>.process(@name)</span><br><span class="line">      <span class="keyword">self</span>.read_yaml(File.join(base, <span class="string">'_layouts'</span>), <span class="string">'search.html'</span>)</span><br><span class="line">      <span class="keyword">self</span>.data[<span class="string">'title'</span>] = <span class="string">"Internal Search"</span></span><br><span class="line">      <span class="keyword">self</span>.data[<span class="string">'index'</span>] = h.to_json</span><br><span class="line">      <span class="keyword">self</span>.data[<span class="string">'worddict'</span>] = l.join(<span class="string">","</span>)</span><br><span class="line">      <span class="comment"># 将倒排索引和倒排词目录写入到page属性中, 从而可以在模板文件中直接写入到html页面中去.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SearchGenerator</span>&lt; Generator</span></span><br><span class="line">    safe <span class="literal">true</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(site)</span></span></span><br><span class="line">      <span class="comment"># 类似tag页面, 这里也把search的这个页面放在了search目录下</span></span><br><span class="line">      <span class="keyword">if</span> site.layouts.key? <span class="string">'search'</span></span><br><span class="line">        dir = site.config[<span class="string">'search_dir'</span>] <span class="params">||</span> <span class="string">'search'</span></span><br><span class="line">        write_search_index(site, File.join(dir, <span class="string">''</span>))</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_search_index</span><span class="params">(site, dir)</span></span></span><br><span class="line">      h = Hash.new</span><br><span class="line">      nh = Hash.new</span><br><span class="line">      po = Hash.new</span><br><span class="line">      <span class="comment"># 三个hash值分别用来存储索引,倒排索引和博文文档信息</span></span><br><span class="line">      tlist = []</span><br><span class="line">      <span class="comment"># 一个array用来存储倒排词表, 这个主要是用来给js做分词词典使用的</span></span><br><span class="line">      keyword = JiebaRb::Keyword.new</span><br><span class="line">      <span class="comment"># 因为jibe的keyword模块, 因为只用到了关键字提取部分 </span></span><br><span class="line">      site.posts.each <span class="keyword">do</span> <span class="params">|post|</span></span><br><span class="line">        <span class="comment"># 逐文提取关键词</span></span><br><span class="line">        alist = []</span><br><span class="line">        keywords_weights = keyword.extract post.content,<span class="number">35</span></span><br><span class="line">        <span class="comment"># 目前只给了35的限制, 其实可以放的更宽些, 目前我20来篇的博文, 基本几秒内就建好了</span></span><br><span class="line">        keywords_weights.each&#123;<span class="params">|k,v|</span></span><br><span class="line">          alist.push(k.downcase)</span><br><span class="line">          <span class="comment"># 将关键词归一化处理存放到列表中 </span></span><br><span class="line">        &#125;</span><br><span class="line">        postdata = Hash.new</span><br><span class="line">        <span class="comment"># 存放post相关的信息</span></span><br><span class="line">        postdata[<span class="string">'post_id'</span>] = post.id</span><br><span class="line">        postdata[<span class="string">'post_url'</span>] = post.url</span><br><span class="line">        postdata[<span class="string">'post_title'</span>] = post.title</span><br><span class="line">        <span class="keyword">if</span> post[<span class="string">"language"</span>] == <span class="string">"en"</span></span><br><span class="line">          postdata[<span class="string">'post_content'</span>] = post.content[<span class="number">0</span>...<span class="number">400</span>].gsub!(<span class="regexp">/(&lt;[^&gt;]*&gt;)|&#123;%|%&#125;|\s|\n|([#]+)|\t/</span>) &#123;<span class="string">" "</span>&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          postdata[<span class="string">'post_content'</span>] = post.content[<span class="number">0</span>...<span class="number">200</span>].gsub!(<span class="regexp">/(&lt;[^&gt;]*&gt;)|&#123;%|%&#125;|\s|\n|([#]+)|\t/</span>) &#123;<span class="string">" "</span>&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment"># 截断正文取摘要, 这里加了个中英文区分</span></span><br><span class="line">        postdata[<span class="string">'post_author'</span>] = post[<span class="string">"author"</span>]</span><br><span class="line">        postdata[<span class="string">'post_category'</span>] = post.categories</span><br><span class="line">        postdata[<span class="string">'post_tags'</span>] = post.tags</span><br><span class="line">        postdata[<span class="string">'post_date'</span>] = post.date</span><br><span class="line">        h[post.url] = alist.uniq</span><br><span class="line">        <span class="comment"># 生成的索引h</span></span><br><span class="line">        <span class="comment"># 将关键词去重处理</span></span><br><span class="line">        po[post.url] = postdata</span><br><span class="line">        tlist = tlist <span class="params">| alist.uniq</span></span><br><span class="line"><span class="params">      <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">      # 创建倒排索引</span></span><br><span class="line"><span class="params">      tlist.each&#123;|</span>k<span class="params">|</span></span><br><span class="line"><span class="params">        klist = []</span></span><br><span class="line"><span class="params">        h.each&#123;|</span>k2,v<span class="params">|</span></span><br><span class="line"><span class="params">          <span class="keyword">if</span> v.<span class="keyword">include</span>? k</span></span><br><span class="line"><span class="params">            klist.push(po[k2])</span></span><br><span class="line"><span class="params">          <span class="keyword">end</span></span></span><br><span class="line"><span class="params">        &#125;</span></span><br><span class="line"><span class="params">        nh[k] = klist</span></span><br><span class="line"><span class="params">      &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">      # 输出页面</span></span><br><span class="line"><span class="params">      index = SearchPage.new(site, site.source, dir, nh, tlist)</span></span><br><span class="line"><span class="params">      index.dir = dir</span></span><br><span class="line"><span class="params">      index.render(site.layouts, site.site_payload)</span></span><br><span class="line"><span class="params">      index.write(site.dest)</span></span><br><span class="line"><span class="params">      site.pages &lt;&lt; index</span></span><br><span class="line"><span class="params">    <span class="keyword">end</span></span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure>

<p>在我们将生成的倒排索引和倒排词表输出到页面后, 就可以着手写页面模板了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">---</span><br><span class="line">layout: home_base</span><br><span class="line">function: search</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;nav id&#x3D;&quot;bread&quot;&gt;</span><br><span class="line">  &lt;h2&gt;&lt;a href&#x3D;&quot;&#x2F;blog&quot;&gt;All Posts&lt;&#x2F;a&gt; &gt;&gt; Search: &lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br><span class="line"></span><br><span class="line">&lt;p style&#x3D;&quot;display:none;&quot; id&#x3D;&quot;indexdata&quot;&gt;&#123;&#123; page.index &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;display:none;&quot; id&#x3D;&quot;worddicts&quot;&gt;&#123;&#123; page.worddict &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% comment %&#125; 将插件中生成的倒排数据和倒排词表存放到隐藏p元素内, 加以id方便js提取 &#123;% endcomment %&#125;</span><br><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;&quot; class&#x3D;&quot;search&quot;&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;search&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Enter to search.&quot;&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;gosearch&quot; type&#x3D;&quot;button&quot;&gt;Go&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;article&gt;</span><br><span class="line">  &lt;ul class&#x3D;&quot;article-list&quot;&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  $(&#39;form.search&#39;).submit(function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    $(&#39;button#gosearch&#39;).trigger(&#39;click&#39;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  $(&#39;button#gosearch&#39;).on(&#39;click&#39;,function()&#123;</span><br><span class="line">    var query &#x3D; $(&#39;input#search&#39;).val();</span><br><span class="line">    search(query);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p>模板的话, 主要根据自己的需要来设置了, 主要是为了将输出的倒排和倒排词表写入文档之中.</p>
<p>那么这一切做好了之后, 我们的<strong>准备工作</strong>部分算是基本完成了. 当你编译后去查看你的search页面时就能看到页面里面已经出现了类似:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"代码": [&#123;</span><br><span class="line">    "post_id": "/2015/05/06/new-blog",</span><br><span class="line">    "post_url": "/2015/05/06/new-blog.html",</span><br><span class="line">    "post_title": "My New Blog",</span><br><span class="line">    "post_content": "在回国前最后一天的时候, 我在BBH列了下回国后要做的几件事, 其中之一就是迁移我的Blog中技术和HCI的部分到github page上来. 到今天终于算是做完了. 内容还没有完全迁移, 也可能不准备迁移内容了... 以后的技术更新和HCI的翻译等等都准备直接发到这里了.    这个blog的设计和结构主要借鉴了[简书](http://www.jianshu.com/), 代码是在我之前的那个b",</span><br><span class="line">    "post_author": "taoalpha",</span><br><span class="line">    "post_category": ["blog"],</span><br><span class="line">    "post_tags": ["介绍"],</span><br><span class="line">    "post_date": "2015-05-06 00:00:00 +0800"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    "post_id": "/2015/05/29/use-jekyll-plugin-with-github-page",</span><br><span class="line">    "post_url": "/2015/05/29/use-jekyll-plugin-with-github-page.html",</span><br><span class="line">    "post_title": "在 Github Pages 中使用Jekyll插件",</span><br><span class="line">    "post_content": "  Github Page的jekyll      Github Page对jekyll的支持是很到位的, 唯一的不足可能也是其本身基于安全考虑而使得jekyll始终都是运行在safe模式, 目前[放开的插件列表非常有限], 所以很多jekyll的插件都无法使用. 当然, 单纯支持的几个插件或者不用插件也是完全可以做出很好的效果的, 不过个人比较喜欢折腾, 所以虽然目前只有一个可有可无的压缩需求",</span><br><span class="line">    "post_author": "taoalpha",</span><br><span class="line">    "post_category": ["tech"],</span><br><span class="line">    "post_tags": ["jekyll", "plugin", "github page"],</span><br><span class="line">    "post_date": "2015-05-29 00:00:00 +0800"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    "post_id": "/2015/06/11/javascript-callback-notes",</span><br><span class="line">    "post_url": "/2015/06/11/javascript-callback-notes.html",</span><br><span class="line">    "post_title": "JavaScript callback学习笔记",</span><br><span class="line">    "post_content": "  缘起    今天帮朋友做一个网站, 涉及到js请求并且渲染数据. 因为js语言的特点使得其代码是由上至下依次执行的, 有一个比较恶心的问题在于这一执行顺序并不等同于其先后顺序, 如果中间有一步或者几步的后续执行比较耗费时间, js本身是不会等待其执行完再去执行下面的语句的. 如此就会出现一些因为执行时间而导致的问题, 尤其是请求和渲染数据的时候. 如果你分开来写, 顺次执行的时候, 请求这一",</span><br><span class="line">    "post_author": "taoalpha",</span><br><span class="line">    "post_category": ["tech"],</span><br><span class="line">    "post_tags": ["js", "callback"],</span><br><span class="line">    "post_date": "2015-06-11 00:00:00 +0800"</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>上面这其实就是你的倒排文档啦~</p>
<h3 id="query分词"><a href="#query分词" class="headerlink" title="query分词"></a>query分词</h3><p>编译部分的工作做完后, 我们就需要开始进行查询部分了. 首当其冲的还是分词.</p>
<p>针对查询这部分的分词方法也有几种不同的方法:</p>
<ul>
<li>借助第三方API, 目前博主知道的有<a href="http://pullword.com/" target="_blank" rel="noopener">pullword</a>, <a href="http://jiebademo.ap01.aws.af.cm/" target="_blank" rel="noopener">jieba-demo</a>, <a href="http://simonfenci.sinaapp.com/index.php?key=simon&wd=%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C" target="_blank" rel="noopener">SAE 搭建</a>. 上述三个博主都试了下… 结果无一例外遇到了跨域问题… 而三者都不是json格式返回, 所以常用的jsonp跨域无法解决…;</li>
<li>手写js实现: 有好有坏, 有的简单有的复杂, 视个人情况而定… 比如博主是因为也没别的法子了…</li>
</ul>
<p>既然决定了自己写, 那么怎么写呢? 首先, 目前主流的中文的分词方法都是<a href="http://www.cnblogs.com/flish/archive/2011/08/08/2131031.html" target="_blank" rel="noopener">字典法</a>, 匹配抽取即可; 也比较容易实现. 而正好我们拥有倒排词表(实际上正是因为要手写需要词典, 所以才导出倒排词表的), 所以可以将倒排词表作为词典文件来切词. 具体的做法简要概述即是:</p>
<p><strong>以倒排词表为词典, 对传入query进行逐个匹配抽取;</strong></p>
<p>我是采用简单的暴力抽取法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">query</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inverted_index = <span class="built_in">JSON</span>.parse($(<span class="string">'p#indexdata'</span>).text());</span><br><span class="line">  <span class="comment">// 拿倒排并且恢复为json格式</span></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> dict = $(<span class="string">'p#worddicts'</span>).text().split(<span class="string">","</span>);</span><br><span class="line">  <span class="comment">// 拿倒排词表,并且恢复为array</span></span><br><span class="line">  query = query.toLowerCase().replace(<span class="regexp">/[(^\s+)(\s+$)]/g</span>,<span class="string">""</span>);</span><br><span class="line">  <span class="comment">// 归一化query... 绝对暴力归一化, 去除所有空格..</span></span><br><span class="line">  <span class="keyword">var</span> splitwords = [];</span><br><span class="line">  $.each(dict,<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(query.indexOf(v)&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">      splitwords.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐个遍历, 不匹配的干掉, 匹配抽取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span>(splitwords.length)&#123;</span><br><span class="line">    <span class="comment">// 准备合并倒排, 这里如果没有抽取出来关键词的话, 就直接pass返回无结果啦哈哈</span></span><br><span class="line">    $.each(splitwords,<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">      result = result.concat(inverted_index[v]);</span><br><span class="line">      <span class="comment">// 合并倒排, 这里使用的是并集, 是因为目前博客文章不多, 所以取交集... 空结果太多..哈哈</span></span><br><span class="line">    &#125;)</span><br><span class="line">    showSearchResult(result.getObjectUnique(<span class="string">'post_url'</span>));</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 无结果提醒</span></span><br><span class="line">    $(<span class="string">'ul.article-list'</span>).empty().append(<span class="string">'&lt;li class="post"&gt;&lt;h2&gt;无结果, 请更换查询词&lt;/h2&gt;&lt;/li&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showSearchResult</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这里主要是沿用了我之前首页的结构~</span></span><br><span class="line">  $(<span class="string">'ul.article-list'</span>).empty();</span><br><span class="line">  <span class="comment">// 记得每次查询前要清掉上次查询结构哦~</span></span><br><span class="line">  <span class="keyword">var</span> template = <span class="string">'&lt;li class="post"&gt;&lt;h2&gt;&lt;a href="__post_url__"&gt;__post_title__&lt;/a&gt;&lt;/h2&gt;&lt;summary class="title-excerpt"&gt;__post_desc__&lt;/summary&gt;&lt;div class="post-info"&gt;&lt;span class="author"&gt;&lt;i class="fa fa-user"&gt;&lt;/i&gt;&lt;a href="__post_author_url__"&gt;__post_author__&lt;/a&gt;&lt;/span&gt;&lt;span class="category"&gt;&lt;i class="fa fa-briefcase"&gt;&lt;/i&gt;&lt;a href="__post_category_url__"&gt;__post_category__&lt;/a&gt;&lt;/span&gt;&lt;span class="postdate"&gt;&lt;i class="fa fa-history"&gt;&lt;/i&gt;__post_date__&lt;/span&gt;&lt;span class="viewcount"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;'</span>;</span><br><span class="line">  $.each(data,<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child = template.replace(<span class="string">"__post_url__"</span>,<span class="string">"/blog"</span>+v.post_url).replace(<span class="string">"__post_title__"</span>,v.post_title).replace(<span class="string">"__post_desc__"</span>,v.post_content+<span class="string">"..."</span>).replace(<span class="string">"__post_author_url__"</span>,<span class="string">"/blog/author/"</span>+v.post_author).replace(<span class="string">"__post_author__"</span>,v.post_author).replace(<span class="string">"__post_category_url__"</span>,v.post_category == <span class="string">"blog"</span>? <span class="string">"/blog"</span>:<span class="string">"/blog/"</span>+v.post_category).replace(<span class="string">"__post_category__"</span>,v.post_category).replace(<span class="string">"__post_date__"</span>,v.post_date.replace(<span class="string">'00:00:00 +0800'</span>,<span class="string">''</span>));</span><br><span class="line">    $(<span class="string">'ul.article-list'</span>).append(child);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此, 基本算是完事了~  如果你想要尝试下我的搜索效果, <a href="/blog/search/">请点此</a></p>
<h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><p>第三方服务的话, 肯定都比我做的这个要精细多了哈哈. 因为博主只了解了下面两个提供此类服务的服务, 所以就简单介绍下这两个:<a href="http://www.searchify.com/documentation/api#searching" target="_blank" rel="noopener">IndexTank</a> 以及 <a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>. </p>
<p>先说下共同点吧:</p>
<ul>
<li>都是<code>full-text-search</code>, 不想我这种是关键词… 而且不一定准确…哈哈</li>
<li>省事, 都是宣称的实时收录~ 给力!</li>
<li>方便, 都是有现成的接口, 比如<code>IndexTank</code>有一个配套的jekyll插件, 可以直接安装调用; <code>swiftype</code>则是代码嵌入型的, 更省事;</li>
<li>都支持中文…</li>
</ul>
<p>恩, 在介绍下不同点:</p>
<h3 id="IndexTank"><a href="#IndexTank" class="headerlink" title="IndexTank"></a>IndexTank</h3><ul>
<li>开源: 赞! 应该是从被<strong>linkedin</strong>收购后就开源了, 名字也改成了searchify~哈哈</li>
<li>30天免费试用; 之后标配是$59/month, doc限制在50w份(写50w的blog也够牛逼了…);</li>
<li>api齐全, <a href="http://www.searchify.com/documentation/api#searching" target="_blank" rel="noopener">IndexTank API</a>, 定制性比较好;</li>
</ul>
<h3 id="Swiftype"><a href="#Swiftype" class="headerlink" title="Swiftype"></a>Swiftype</h3><ul>
<li>半开源: <a href="https://github.com/swiftype" target="_blank" rel="noopener">Swiftype Github</a>, 基本都是其在各个语言下的支持库;</li>
<li>有免费服务: 只支持一个服务, 文档更新不如付费版本来的及时, 也不提供搜索数据分析等等, 不过, 绝对够用…</li>
<li>可少量定制: 可以做轻微的定制;</li>
<li>超省事儿: 基本可以说几行代码搞定的节奏…</li>
</ul>
<p>从某种程度上说, swiftype算是个轻量级的Google CSE(自定义搜索引擎). 恩, Google的CSE其实可以算是博主知道的第三个…</p>
<p>PS. 这里有个使用了swiftype服务的hexo博客, 有兴趣的可以看看: <a href="http://notes.iissnan.com/#stq=%E6%B5%8B%E8%AF%95&stp=1" target="_blank" rel="noopener">IIssNan’s Notes</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/altkatz/jieba_rb" target="_blank" rel="noopener">jieba_rb Github</a></li>
<li><a href="http://my.oschina.net/goal/blog/201674" target="_blank" rel="noopener">JavaScript 实现简单的中文分词</a> 很赞, 但是我没用.. 主要是我的太明显了.. 简单暴力就可以搞定了…</li>
<li><a href="https://github.com/olivernn/lunr.js" target="_blank" rel="noopener">Lunr.js Github</a> js搜索的前辈级产品, 可惜最后也没用</li>
<li><a href="http://www.cnblogs.com/flish/archive/2011/08/08/2131031.html" target="_blank" rel="noopener">中文分词技术介绍</a></li>
</ul>
</div><div class="post-info"><span class="category"><i class="fas fa-briefcase"></i><a href="/blog/categories/tech">tech</a></span><span class="tags"><i class="fas fa-tags"></i><a href="/blog/tags/jekyll">jekyll</a><a href="/blog/tags/%E5%86%85%E7%BD%AE%E6%90%9C%E7%B4%A2">内置搜索</a><a href="/blog/tags/search-engine">search engine</a><a href="/blog/tags/%E5%80%92%E6%8E%92">倒排</a></span></div></section><div class="widgets"><aside id="menuIndex" class="sidenav hidden"></aside><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: Jekyll Boost<i class="fas fa-arrow-down expand"></i><i class="collapse fas fa-arrow-up"></i></h2><ul class="article-list hidden"><li><a href="/blog/2015/06/21/tech-add-internal-search-to-jekyll-blog/" data-id='0' class="current">自建倒排, 为 Jekyll 博客添加搜索功能</a></li><li><a href="/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/" data-id='1'>Jekyll 中如何做中文字数统计</a></li><li><a href="/blog/2015/06/02/tech-jekyll-paginator-for-all-page/" data-id='2'>Jekyll 添加翻页部分(包含分类页,标签页)</a></li><li><a href="/blog/2015/06/06/tech-jekyll-related-posts-optimization/" data-id='3'>优化 Jekyll 的相关文章列表</a></li><li><a href="/blog/2015/06/01/tech-jekyll-tag-page/" data-id='4'>Jekyll 添加 tag 专属页面</a></li></ul></aside><div class="related-posts sidenav"><h2>Related Posts:</h2><ul class="article-list"><li><a href="/blog/2015/07/09/tech-change-internal-search-to-swiftype/">Add Swiftype as my default internal search engine</a></li><li><a href="/blog/2015/06/07/tech-add-google-analytics-pageviews-to-jekyll-blog/">如何给 Jekyll 博文添加阅读数显示</a></li><li><a href="/blog/2015/06/06/tech-jekyll-related-posts-optimization/">优化 Jekyll 的相关文章列表</a></li><li><a href="/blog/2015/06/02/tech-jekyll-paginator-for-all-page/">Jekyll 添加翻页部分(包含分类页,标签页)</a></li><li><a href="/blog/2015/06/01/tech-jekyll-tag-page/">Jekyll 添加 tag 专属页面</a></li></ul></div><aside class="sidenav"><div class="recent-posts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="/blog/2020/07/04/travel-working-holiday-visa-3/">打工度假 (三)</a></li><li><a href="/blog/2020/07/02/travel-working-holiday-visa-2/">打工度假 (二)</a></li><li><a href="/blog/2020/07/02/tech-what-i-have-done-to-restart-this-blog/">我都做了哪些来复活本博客的</a></li><li><a href="/blog/2020/07/01/travel-working-holiday-visa/">打工度假 (一)</a></li><li><a href="/blog/2020/06/30/tech-gitment-and-gittalk/">Gitment and Gitalk</a></li></ul></div></aside></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><div class="comments"><script>const gitment = new Gitment({
  id: new Date('Sun Jun 21 2015 06:00:00 GMT-0400').toISOString(),
  owner: 'taoalpha',
  repo: 'blog',
  oauth: {
    client_id: '875872ffb3955d0ffe20',
    client_secret: '46040668c536860a9e2e9a8508c513309e3840b5',
  },
});
gitment.render(document.querySelector('.comments'));
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>