<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript the Definitive Guide (3) | TaoAlpha's Blog</title><meta name="description" content="今天翻了下新版(第六版)的definitive guide, 发现有不少改动, 所幸之前也只是看了1/5, 所以就重头开始再翻一遍第六版, 本文算是对这一版的前4个chapter的一次查漏补缺."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:title" content="JavaScript the Definitive Guide (3) | TaoAlpha's Blog"><meta property="og:description" content="今天翻了下新版(第六版)的definitive guide, 发现有不少改动, 所幸之前也只是看了1/5, 所以就重头开始再翻一遍第六版, 本文算是对这一版的前4个chapter的一次查漏补缺."><meta property="og:url" content="undefined"><meta property="og:image" content="http://taoalpha.github.io/images/newblog.jpg"><meta property="og:type" content="website"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.6.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="TaoAlpha's Blog" type="application/atom+xml">
<link rel="alternate" href="/blog/rss2.xml" title="TaoAlpha's Blog" type="application/rss+xml">
</head><body class="post"><aside class="home-menu"><nav class="home-icon-con upside"><a href="/blog/" class="home-menu-icon brand">涛</a><a href="/blog/timeline" class="home-menu-icon"><i class="fas fa-map-marker-alt"></i></a><a aria-label="Click to take you to the search box." class="home-menu-icon search-trigger hint--right"><i class="fas fa-search"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact hidden"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.github.io" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div></nav><nav class="home-icon-con downside"><a href="/blog/rss2.xml" class="home-menu-icon rss"><i class="fas fa-rss"></i></a><a href="/blog/about/" class="home-menu-icon"><i class="fas fa-smile"></i></a><span id="dark-mode" class="home-menu-icon hidden"><i class="fas fa-adjust"></i></span></nav></aside><div class="stars"></div><div class="twinkling"></div><div id="progress-bar" class="hidden"><span class="bg"></span></div><article id="content"><div class="main"><section class="entry"><h1 class="entry-title">JavaScript the Definitive Guide (3)</h1><div class="meta-top"><a href="https://taoalpha.github.io"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2015-06-22</span><span class="wordage">6775 words</span><span class="readspeed">20 minutes to read</span></div><div class="entry-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先说点不相关的… 为了更好的阅读, 所以以后<code>读书笔记</code>相关的博文都会分拆成4个部分:</p>
<ul>
<li><strong>概述:</strong> 算是阅读总结摘要以及类似这段话之类的声明介绍等等;</li>
<li><strong>阅读笔记:</strong> 这部分主要以阅读过程中的记录为主, 会比较杂, 基本算是逐点记录, 评判相对主观;</li>
<li><strong>心得:</strong> 这部分则主要为笔记的延伸, 算是对笔记的一种补充或者说自己的阅读理解消化所得, 有时候也会覆盖到一些使用架桥等等;</li>
<li><strong>谜题:</strong> 这里主要记录一些没有完全理解的部分, 会加上自己的猜测解答, 当弄懂后会更新<strong>正解</strong>;</li>
</ul>
<p>DONE.</p>
<p>本篇是博主重新翻阅了”JavaScript the Definitive Guide(第六版)”的前4章内容(之前 <a href="/blog/2015/06/17/readings-reading-javascript-the-definitive-guide-1/" title="阅读笔记-1">阅读笔记-1</a>以及<a href="/blog/2015/06/18/readings-javascript-the-definitive-guide-2/" title="阅读笔记-2">阅读笔记-2</a> 均是第五版的)后的读书笔记以及心得体会. 内容主要覆盖js的基本用法, 考虑到重复, 这里主要是在上两篇的基础上查漏补缺.</p>
<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><h3 id="Chapter-2-基础知识"><a href="#Chapter-2-基础知识" class="headerlink" title="Chapter 2 - 基础知识"></a>Chapter 2 - 基础知识</h3><h4 id="JS能识别的whitespaces"><a href="#JS能识别的whitespaces" class="headerlink" title="JS能识别的whitespaces:"></a>JS能识别的<code>whitespaces</code>:</h4><ul>
<li>常规空格: <code>\u0020</code> # 即url中常见的<code>%20</code></li>
<li>Tab(制表符): <code>\u0009</code> # js中常见的<code>\t</code></li>
<li>Vertical Tab: <code>\u000B</code> # <code>\v</code></li>
<li>Form Feed(翻页/页码分隔符): <code>\u000C</code> # <code>\f</code></li>
<li>Nonbreaking Space(不间断空格): <code>\u00A0</code>  # 通常在html中用来阻止默认连续多空格自动归一的性质(auto collapsing)而使用<code>&amp;nbsp;</code>, 同时因为软件处理的需要, 使用<code>&amp;nbsp;</code>能够防止相应的处理器将普通空格转为行分隔;</li>
<li>Byte order mark: <code>\uFEFF</code></li>
<li>any character in Unicode category Zs</li>
</ul>
<h4 id="JS能识别的line-terminators"><a href="#JS能识别的line-terminators" class="headerlink" title="JS能识别的line terminators:"></a>JS能识别的<code>line terminators</code>:</h4><ul>
<li>line feed: <code>\u000A</code> # <code>\n</code></li>
<li>carriage return: <code>\u000D</code> # <code>\r</code></li>
<li>line separator: <code>\u2028</code></li>
<li>paragraph separator: <code>\u2029</code></li>
</ul>
<p><strong>值得一说的是, js是支持unicode作为<code>indentifier</code>的合法字符的, 但是上述这些则不在其中.</strong></p>
<h4 id="JS的”Unicode-Escape-Sequences”"><a href="#JS的”Unicode-Escape-Sequences”" class="headerlink" title="JS的”Unicode Escape Sequences”"></a>JS的”Unicode Escape Sequences”</h4><p>类似”\u00E9”这种结构的字符在js都代表一种特殊的字符:”unicode”. 如果你在js中使用这些字符, js会自动将其编译为对应的字符(如果是在js的注释中, 则不会编译, 而是以ascii对待), 比如: 示例就会编译为”é”. 而在js中, 这种对等关系是支持的, 即 <code>&quot;\u00E9&quot; === &quot;é&quot;</code>是为真的.</p>
<p>但是一定要慎用… 因为unicode变化过多, 有时候输出看起来一样的字符, 其本质不一定一样: <code>&quot;e\u0301&quot;</code>的输出也是”é”, 但是它相当于是<code>&quot;e&quot;+&quot;\u0301&quot;</code>组成的.</p>
<h4 id="JS中的-quot-quot"><a href="#JS中的-quot-quot" class="headerlink" title="JS中的&quot;;&quot;"></a>JS中的<code>&quot;;&quot;</code></h4><p>在JS中, <code>&quot;;&quot;</code>作为语句结尾并不是必须的, 只有当多语句同行的时候, <code>&quot;;&quot;</code>才是必须的. 当你没有<code>&quot;;&quot;</code>的时候, js会自动为你添加合适的<code>&quot;;&quot;</code>. 通常它会自动将它没有<code>&quot;;&quot;</code>无法解析代码时候遇到的换行处加以<code>&quot;;&quot;</code>(除了类似return,break, ++, –等, 它会自动将其后的行分隔符作为<code>&quot;;&quot;</code>对待.):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line">a</span><br><span class="line">=</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// output: 3</span></span><br><span class="line"><span class="comment">// js在第一个换行处识别了其语句分割的意义, 但是在 a = 3 的两个分割处都因为它可以识别合并后的语句所以没有作为`";"`处理.</span></span><br></pre></td></tr></table></figure>

<p>但是上述的成功不意味着js的智能, 更多时候如果我们不合适的使用<code>&quot;;&quot;</code>, 会造成很多奇怪的问题的, 比如以<code>(, [, /, +, -</code>为起始的语句很可能会被误认为是前一语句的延续. 所以通常来说, js的编码还是比较鼓励使用<code>&quot;;&quot;</code>作为语句结尾的.</p>
<h3 id="Chapter-3-数据类型"><a href="#Chapter-3-数据类型" class="headerlink" title="Chapter 3 - 数据类型"></a>Chapter 3 - 数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number:"></a>Number:</h4><ul>
<li><strong>Global viriables:</strong> <code>Infinity</code>,<code>NaN</code></li>
<li><strong>Global Objects:</strong> <code>Math</code>,<code>Number</code></li>
</ul>
<p>Tips:</p>
<ul>
<li><code>NaN</code> 具有唯一性, 其不等于任意值, 包括它自己, <code>0/0</code>会产生’NaN’, 但是<code>0/0 != NaN</code>, 如果需要判断一个变量是不是NaN, 需要使用<code>isNaN()</code>这个内置的函数;</li>
<li><code>Infinity &lt;==&gt; Number.POSITIVE_INFINITY &lt;==&gt; 1/0</code></li>
<li><code>-Infinity &lt;==&gt; Number.NEGATIVE_INFINITY &lt;==&gt; -1/0</code></li>
<li><code>Binary Floating-Point</code>会导致小数级错误, 比如<code>0.3-0.2 != 0.2-0.1</code>, 这个属于计算机本身因为二进制编码的原因所致, 所以在比较数字大小的时候要格外小心;</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h3><ul>
<li><strong>immutable ordered sequence of 16-bit values</strong></li>
</ul>
<p>Tips:</p>
<ul>
<li>string的长度都是按照16-bit来计算的, 所以当如果一个字符超过了16-bit, 则会按照多的计算. 比如: <code>e - \ud835\udc52</code>, 就需要按照两个16bit计算, 即其长度应为:”2”</li>
<li>从ECMAScript 5之后就允许string跨行定义了, 只需要在换行的地方加上一个反斜杠<code>\</code>, 即可.</li>
<li>转义字符<code>\</code>如果加在普通字符前, 不会产生任何效果;</li>
<li><code>typeof null =&gt; Object</code> , <code>typeof undefined =&gt; undefined</code>;</li>
<li><code>null == undefined</code>, <code>null!==undefined</code> =&gt; True</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>javascript是一个很宽松的语言, 我们不需要预先定义变量类型, 而在运算以及执行过程中, js也会自动的帮助我们进行类型转换, 当然为了更好的借助这一特点, 了解下图中的js转换类型的规则还是非常有必要的.</p>
<img class="2015-06-22&#x2F;javascript-type-convertion.jpg alt&#x3D;JavaScript Type Convertions title&#x3D;JavaScript Type Convertions [no-autosize]">

<p>其中object转换 primitive datatype 的话, 一般会按照如下步骤进行:</p>
<ul>
<li>首先会默认调用<code>toString()</code>函数, 你可以自行定义这一函数, 如果<code>toString()</code>返回结果正常, 则转换结束;</li>
<li>如果<code>toString()</code>未定义, 或者返回结果非<code>primitive datatype</code>的话, 会自动调用<code>valueOf()</code>函数, 同上一步;</li>
<li>而如果两个都没找到, 那么js将会抛出<code>TypeError</code>;</li>
</ul>
<p>而根据要转换的是<code>string</code>还是<code>number</code>而交换1,2两步( <code>string</code> 的话先调用<code>toString()</code>, 且返回值必然会转为string; 如果是<code>number</code>的话, 则先找<code>valueOf()</code>, 返回结果为number). 当然至于boolean的话, 所有的object转换到boolean都是true.</p>
<p>Array转换<code>string</code>的时候默认的<code>toString()</code>就是一个<code>join()</code>调用~ Function的话, 则也可以自己定义<code>toString()</code>函数.</p>
<p>Tips:</p>
<ul>
<li>x + “” // Same as String(x)</li>
<li>+x // Same as Number(x). You may also see x-0</li>
<li>!!x // Same as Boolean(x). Note double !</li>
<li>在ECMAScript 5的strict模式下, 所有变量君需要声明才能赋值, 否则会报错;</li>
</ul>
<h3 id="Chapter-4-Expressions-and-Operators"><a href="#Chapter-4-Expressions-and-Operators" class="headerlink" title="Chapter 4: Expressions and Operators"></a>Chapter 4: Expressions and Operators</h3><img class="2015-06-22&#x2F;javascript-operators.jpg alt&#x3D;JavaScript Operators title&#x3D;JavaScript Operators [no-autosize]">

<p>上图为按照优先级顺序排列下来的操作符(横线分隔的同一组块之间的级别相同).</p>
<p>Tips:</p>
<ul>
<li><p>运算顺序不影响赋值顺序, 赋值顺序始终都是严格从左到右的, 比如:<code>h = x+y+z</code>, 那么赋值顺序始终都是<code>h-&gt;x-&gt;y-&gt;z</code>; 通常情况下, 这一赋值顺序不会影响之后的计算顺序, 对结果基本没什么影响, 除了一种情况:</p>
<p>如果前变量的赋值会影响到后面变量的值的话, 比如共用同一个变量, 那么这种情况下, 赋值顺序就<strong>可能</strong>会对结果产生一定的影响了. 最简单的例子就是<code>z = 2;y = function(){z = 3;return 1};</code>, 因为y是一个函数, 而它的执行会改变z的值, 所以<code>y()+z</code>和<code>z+y()</code>的结果就是不相同的.</p>
</li>
<li><p>“+”运算符中的类型转换:</p>
<ul>
<li>string优先, 只要有两个操作数中有一个是string或者是有<code>toString()</code>的object, 那么其都会按照string来进行链接运算;</li>
<li>除非两个都是非string, 才会进行加法运算;</li>
<li>当”+”作为单操作数时, 则意味着将操作数向number类型转换;</li>
</ul>
</li>
<li><p><code>&amp;&amp;</code>运算符如果第一个为false, 则不执行第二条判断, 所以可以用这个方法来代替if: <code>(a==b) &amp;&amp; alert(&quot;a equals b&quot;)</code>就相当于<code>if(a==b) alert(&quot;a equals b&quot;)</code>.</p>
</li>
<li><p><code>!(p &amp;&amp; q) === !p || !q</code></p>
</li>
<li><p><code>!(p || q) === !p &amp;&amp; !q</code></p>
</li>
<li><p><code>a op= b</code> 和 <code>a = a op b</code>通常是等价的, 除非a本身的重复赋值会有副作用, 比如 <code>a[i++] += 1</code>和<code>a[i++] = a[i++] +1</code>就不一样, 因为后者前后两个<code>i</code>不同了.</p>
</li>
<li><p><code>eval()</code>函数会继承当前的scope, 除非eval()被赋予某个新的reference, 那样的话只会使用global的scope;</p>
</li>
<li><p><code>void</code>操作数很少用到, 它是个单操作数的操作符, 其用法就是丢弃操作数的返回结果, 然后返回 undefined…</p>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="whitespaces-和-line-terminators"><a href="#whitespaces-和-line-terminators" class="headerlink" title="whitespaces 和 line terminators"></a>whitespaces 和 line terminators</h3><p>通常在js里面我们使用<code>\s</code>来统一代表所有其可以识别的<code>whitespace</code>, <code>line terminators</code>. 如下例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> k = <span class="string">'asd \t asdasd \na asd \f asda dad\rasd\u2028asd\u2029\u00A0'</span></span><br><span class="line">k</span><br><span class="line"><span class="comment">// output 里面有两个换行的符号, 我这里为了演示方便就不换行了</span></span><br><span class="line">k.replace(<span class="regexp">/\n/g</span>,<span class="string">'-'</span>)</span><br><span class="line"><span class="comment">// 同上,里面的"\r"我也不换行了</span></span><br><span class="line">k.replace(<span class="regexp">/\s/g</span>,<span class="string">'-'</span>)</span><br><span class="line"><span class="comment">// output: "asd---asdasd--a-asd---asda-dad-asd-asd--"</span></span><br></pre></td></tr></table></figure>

<p>因为在console中输出的时候是不换行的, 所以有时候单单看console输出的话, 类似这种编码问题所致的错误就找不出来, 为了省事, 我们可以统一使用<code>\s</code>来代表所有此类符号.</p>
<h2 id="谜题"><a href="#谜题" class="headerlink" title="谜题"></a>谜题</h2><p>Q: 按照正常来说<code>Number.MAX_VALUE</code>加上一个数应该就会自动转为<code>Infinity</code>, 但实际上, 测试过程中发现, 只有当<code>Number.MAX_VALUE</code>加上一个<strong>足够大的数</strong>后才会等与<code>Infinity</code>, 这是为什么?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="comment">// output: 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE +<span class="number">1</span></span><br><span class="line"><span class="comment">// output: 1.7976931348623157e+308</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Math</span>.pow(<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// output: Infinity</span></span><br></pre></td></tr></table></figure>

<p><strong>正解:</strong> <em><strong>the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign.</strong></em></p>
<blockquote>
<p>IEEE 754</p>
</blockquote>
<blockquote>
<p>In the following two rounding-direction attributes, an infinitely precise result with magnitude at least bemax ( b − ½ b^(1-p) ) shall round to ∞ with no change in sign; here emax and p are determined by the destination format (see 3.3). With:</p>
</blockquote>
<blockquote>
<ul>
<li><strong>roundTiesToEven:</strong> the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with an even least significant digit shall be delivered</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>roundTiesToAway:</strong> the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with larger magnitude shall be delivered.</li>
</ul>
</blockquote>
<p><em><strong>ECMAScript does not specify which of the round-to-nearest, but it doesn’t matter here because both gives the same result. The number in ECMAScript is “double”, in which</strong></em></p>
<ul>
<li>b = 2</li>
<li>emax = 1023</li>
<li>p = 53,</li>
</ul>
<p><em><strong>so the result must be at least 2^1024 - 2^970 ~ 1.7976931348623158 × 10^308 in order to round to infinity. Otherwise it will just round to MAX_VALUE, because that is the closer than Infinity.Notice that MAX_VALUE = 21024 - 2971, so you need to add at least 2^971 - 2^970 = 2^970 ~ 9.979202 × 10^291 in order to get infinity.</strong></em></p>
<p>Q: <code>&#39;0&#39; == false</code> 是 true, 为什么 <code>null == false</code> 就是 false呢?</p>
<p><strong>猜测解释:</strong> <code>==</code>这样的是比较<code>value</code>的, 而 <code>null</code>转换为<code>boolean</code>类型为<code>false</code>, 并不意味着两者的<code>value</code>是相同的. <code>==</code>只会比较<code>value</code>, 而不会进行转换. 也即<code>true</code>, <code>false</code>两个<code>boolean</code>类型的其<code>value</code>也是<code>1,0</code>. 而<code>null</code>和<code>undefined</code>的<code>value</code>则不同, 前者为空, 后者为无.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><ul>
<li><a href="http://book.douban.com/subject/5303032/" target="_blank" rel="noopener">JavaScript the Definitive Guide 6th edition</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category" target="_blank" rel="noopener">Unicode Property</a></li>
<li><a href="http://en.wikipedia.org/wiki/List_of_Unicode_characters" target="_blank" rel="noopener">List of Unicode Characters</a></li>
<li><a href="http://www.qianxingzhem.com/post-1499.html" target="_blank" rel="noopener">编码历史介绍</a></li>
</ul>
</div><div class="post-info"><span class="category"><i class="fas fa-briefcase"></i><a href="/blog/categories/readings">readings</a></span><span class="tags"><i class="fas fa-tags"></i><a href="/blog/tags/js">js</a><a href="/blog/tags/reading-notes">reading notes</a></span></div></section><div class="widgets"><aside id="menuIndex" class="sidenav hidden"></aside><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: Basic Guide for JavaScript<i class="fas fa-arrow-down expand"></i><i class="collapse fas fa-arrow-up"></i></h2><ul class="article-list hidden"><li><a href="/blog/2015/06/17/readings-reading-javascript-the-definitive-guide-1/" data-id='0'>JavaScript the Definitive Guide (1)</a></li><li><a href="/blog/2015/06/18/readings-javascript-the-definitive-guide-2/" data-id='1'>JavaScript the Definitive Guide (2)</a></li><li><a href="/blog/2015/06/22/readings-javascript-the-definitive-guide-3/" data-id='2' class="current">JavaScript the Definitive Guide (3)</a></li><li><a href="/blog/2015/06/23/readings-javascript-the-definitive-guide-4/" data-id='3'>JavaScript the Definitive Guide (4)</a></li><li><a href="/blog/2015/06/24/readings-javascript-the-definitive-guide-5/" data-id='4'>JavaScript the Definitive Guide (5)</a></li><li><a href="/blog/2015/06/25/readings-javascript-the-definitive-guide-6/" data-id='5'>JavaScript the Definitive Guide (6)</a></li></ul></aside><aside class="sidenav"><div class="recent-posts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="/blog/2020/07/06/thoughts-recommendation-to-new-grads-on-job-choices/">给新计算机毕业生在工作选择上的一些建议</a></li><li><a href="/blog/2020/07/04/travel-working-holiday-visa-3/">打工度假 (三)</a></li><li><a href="/blog/2020/07/02/travel-working-holiday-visa-2/">打工度假 (二)</a></li><li><a href="/blog/2020/07/02/tech-what-i-have-done-to-restart-this-blog/">我都做了哪些来复活本博客的</a></li><li><a href="/blog/2020/07/01/travel-working-holiday-visa/">打工度假 (一)</a></li></ul></div></aside></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><div class="comments"><script>const gitment = new Gitment({
  id: new Date('Mon Jun 22 2015 00:00:00 GMT-0400').toISOString(),
  owner: 'taoalpha',
  repo: 'blog',
  oauth: {
    client_id: '875872ffb3955d0ffe20',
    client_secret: '46040668c536860a9e2e9a8508c513309e3840b5',
  },
});
gitment.render(document.querySelector('.comments'));
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>